// server/controllers/shipmentController.js
const { PrismaClient } = require('@prisma/client');
const axios = require('axios');
const prisma = new PrismaClient();

// Delhivery Configuration
const DELHIVERY_API_KEY = process.env.DELHIVERY_API_KEY;
const DELHIVERY_API_URL = process.env.DELHIVERY_API_URL || 'https://api.delhivery.com/api/shipments/create/json/';
const DELHIVERY_PICKUP_URL = process.env.DELHIVERY_PICKUP_URL || 'https://api.delhivery.com/api/p/pickup/';
const DELHIVERY_TRACKING_URL = process.env.DELHIVERY_TRACKING_URL || 'https://api.delhivery.com/api/v1/packages/json/';

// Seller/Warehouse Info (stored in .env)
const SELLER_NAME = process.env.SELLER_NAME || 'Urbaneigh';
const SELLER_ADDRESS = process.env.SELLER_ADDRESS || '';
const SELLER_PHONE = process.env.SELLER_PHONE || '';
const SELLER_EMAIL = process.env.SELLER_EMAIL || '';
const WAREHOUSE_PINCODE = process.env.WAREHOUSE_PINCODE || '';
const WAREHOUSE_CITY = process.env.WAREHOUSE_CITY || '';

// ============================================================================
// CREATE SHIPMENT (Send order to Delhivery, get AWB)
// ============================================================================
exports.createShipment = async (req, res) => {
  try {
    const { orderId } = req.body;

    if (!orderId) {
      return res.status(400).json({ error: 'Order ID is required' });
    }

    // Fetch order with items and customer info
    const order = await prisma.order.findUnique({
      where: { id: parseInt(orderId) },
      include: {
        user: true,
        items: { include: { variant: { include: { product: true } } } },
        payment: true,
        shipments: true
      }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    // Check if shipment already exists
    if (order.shipments && order.shipments.length > 0) {
      return res.status(400).json({ error: 'Shipment already created for this order' });
    }

    // Order must be PAID to create shipment
    if (order.status !== 'PAID') {
      return res.status(400).json({ error: `Order must be PAID to create shipment. Current status: ${order.status}` });
    }

    // Parse shipping address
    const address = order.shippingAddress;

    // Calculate total weight (for demo, assuming 500g per item)
    let totalWeight = 0;
    let itemDescription = '';
    for (const item of order.items) {
      totalWeight += 500; // 500g per item
      itemDescription += `${item.variant.product.title} (${item.quantity}x), `;
    }
    itemDescription = itemDescription.slice(0, -2);

    // Calculate dimensions (for demo)
    const length = 20;
    const width = 15;
    const height = 10;

    // COD amount only if payment method is COD
    const codAmount = order.paymentMethod === 'COD' ? Number(order.totalAmount) : 0;

    // Build Delhivery payload
    const shipmentData = {
      shipments: [
        {
          name: address.fullName || order.user.name,
          email: order.user.email,
          phone: address.phone || order.user.phone,
          address: address.address,
          city: address.city,
          state: address.state || 'IN',
          pincode: address.pincode,
          country: 'IN',
          order_id: String(order.orderNumber),
          shipment_length: length,
          shipment_width: width,
          shipment_height: height,
          weight: totalWeight,
          product_description: itemDescription,
          cod_amount: codAmount,
          return_address: SELLER_ADDRESS,
          return_city: WAREHOUSE_CITY,
          return_pincode: WAREHOUSE_PINCODE,
          return_phone: SELLER_PHONE,
          return_email: SELLER_EMAIL,
          return_name: SELLER_NAME
        }
      ]
    };

    // Call Delhivery API
    let delhiveryResponse;
    try {
      delhiveryResponse = await axios.post(DELHIVERY_API_URL, shipmentData, {
        headers: {
          'Authorization': `Token ${DELHIVERY_API_KEY}`,
          'Content-Type': 'application/json'
        }
      });
    } catch (error) {
      console.error('Delhivery API error:', error.response?.data || error.message);
      return res.status(500).json({
        error: 'Failed to create shipment with Delhivery',
        details: error.response?.data?.error || error.message
      });
    }

    // Parse Delhivery response
    if (!delhiveryResponse.data || !delhiveryResponse.data.shipments || delhiveryResponse.data.shipments.length === 0) {
      return res.status(500).json({ error: 'Invalid response from Delhivery API' });
    }

    const delhiveryShipment = delhiveryResponse.data.shipments[0];
    const waybill = delhiveryShipment.waybill;

    if (!waybill) {
      return res.status(500).json({ error: 'No waybill generated by Delhivery' });
    }

    // Create shipment record in database
    const shipment = await prisma.shipment.create({
      data: {
        orderId: order.id,
        courier_provider: 'DELHIVERY',
        waybill: waybill,
        status: 'CREATED',
        delhivery_waybill: waybill,
        cod_amount: codAmount,
        delhivery_last_status_update: delhiveryResponse.data
      }
    });

    // NOTE: Do NOT update order.status here
    // Order.status tracks PAYMENT READINESS only
    // Shipment.status tracks DELIVERY progress independently

    res.status(201).json({
      message: 'Shipment created successfully',
      shipment: shipment,
      waybill: waybill,
      delhiveryResponse: delhiveryResponse.data
    });

  } catch (error) {
    console.error('Shipment creation error:', error);
    res.status(500).json({ error: error.message });
  }
};

// ============================================================================
// SCHEDULE PICKUP (Send pickup request to Delhivery)
// ============================================================================
exports.schedulePickup = async (req, res) => {
  try {
    const { shipmentIds, pickupDate } = req.body;

    if (!shipmentIds || !Array.isArray(shipmentIds) || shipmentIds.length === 0) {
      return res.status(400).json({ error: 'Shipment IDs array is required' });
    }

    // Fetch shipments
    const shipments = await prisma.shipment.findMany({
      where: { id: { in: shipmentIds } },
      include: { order: true }
    });

    if (shipments.length === 0) {
      return res.status(404).json({ error: 'No shipments found' });
    }

    // Build pickup request
    const pickupData = {
      pickup_location: {
        name: SELLER_NAME,
        email: SELLER_EMAIL,
        phone: SELLER_PHONE,
        address: SELLER_ADDRESS,
        city: WAREHOUSE_CITY,
        pincode: WAREHOUSE_PINCODE
      },
      shipment_id: shipments.map(s => s.delhivery_waybill).filter(Boolean),
      expected_date: pickupDate || new Date().toISOString().split('T')[0],
      notes: 'Batch pickup request'
    };

    // Call Delhivery Pickup API
    let pickupResponse;
    try {
      pickupResponse = await axios.post(DELHIVERY_PICKUP_URL, pickupData, {
        headers: {
          'Authorization': `Token ${DELHIVERY_API_KEY}`,
          'Content-Type': 'application/json'
        }
      });
    } catch (error) {
      console.error('Delhivery Pickup API error:', error.response?.data || error.message);
      return res.status(500).json({
        error: 'Failed to schedule pickup with Delhivery',
        details: error.response?.data?.error || error.message
      });
    }

    // Update shipments with pickup info
    if (pickupResponse.data && pickupResponse.data.pickup_id) {
      const pickupId = pickupResponse.data.pickup_id;

      await prisma.shipment.updateMany({
        where: { id: { in: shipmentIds } },
        data: {
          delhivery_pickup_id: pickupId,
          status: 'MANIFESTED',
          manifestedAt: new Date()
        }
      });
    }

    res.status(200).json({
      message: 'Pickup scheduled successfully',
      pickupId: pickupResponse.data?.pickup_id,
      shipmentsUpdated: shipmentIds.length
    });

  } catch (error) {
    console.error('Pickup scheduling error:', error);
    res.status(500).json({ error: error.message });
  }
};

// ============================================================================
// GET TRACKING (Fetch tracking info from Delhivery)
// ============================================================================
exports.getTracking = async (req, res) => {
  try {
    const { waybill } = req.query;

    if (!waybill) {
      return res.status(400).json({ error: 'Waybill number is required' });
    }

    // Call Delhivery Tracking API
    let trackingResponse;
    try {
      trackingResponse = await axios.get(`${DELHIVERY_TRACKING_URL}?waybill=${waybill}`, {
        headers: {
          'Authorization': `Token ${DELHIVERY_API_KEY}`
        }
      });
    } catch (error) {
      console.error('Delhivery Tracking API error:', error.response?.data || error.message);
      return res.status(500).json({
        error: 'Failed to fetch tracking information',
        details: error.response?.data?.error || error.message
      });
    }

    if (trackingResponse.data && trackingResponse.data.ShipmentData && trackingResponse.data.ShipmentData.length > 0) {
      const shipmentData = trackingResponse.data.ShipmentData[0];

      res.status(200).json({
        message: 'Tracking information fetched',
        tracking: {
          waybill: shipmentData.Waybill,
          status: shipmentData.Status,
          scans: shipmentData.ScanDetailss || [],
          expectedDelivery: shipmentData.Expected_Delivery_Date,
          lastUpdate: shipmentData.Last_Scanned_DateTime
        }
      });
    } else {
      res.status(404).json({ error: 'Tracking information not found' });
    }

  } catch (error) {
    console.error('Tracking fetch error:', error);
    res.status(500).json({ error: error.message });
  }
};

// ============================================================================
// DELHIVERY WEBHOOK (Receive tracking updates from Delhivery)
// ============================================================================
exports.delhiveryWebhook = async (req, res) => {
  try {
    const data = req.body;

    // Delhivery sends tracking updates
    if (!data.waybill) {
      return res.status(400).json({ error: 'Waybill is required' });
    }

    // Find shipment by waybill
    const shipment = await prisma.shipment.findUnique({
      where: { waybill: data.waybill },
      include: { order: true }
    });

    if (!shipment) {
      console.warn(`Webhook: Shipment not found for waybill ${data.waybill}`);
      return res.status(404).json({ error: 'Shipment not found' });
    }

    // Map Delhivery status to our shipment status
    const statusMap = {
      'PICKED': 'PICKED_UP',
      'INTRANSIT': 'IN_TRANSIT',
      'OUT_FOR_DELIVERY': 'OUT_FOR_DELIVERY',
      'DELIVERED': 'DELIVERED',
      'UNDELIVERED': 'FAILED',
      'RTO': 'FAILED'
    };

    const newStatus = statusMap[data.status] || data.status;

    // Update shipment
    const updatedShipment = await prisma.shipment.update({
      where: { id: shipment.id },
      data: {
        status: newStatus,
        delhivery_last_status_update: data,
        last_tracking_update: new Date(),
        delivered_at: newStatus === 'DELIVERED' ? new Date() : null
      }
    });

    // Auto-generate OTP for COD orders when OUT_FOR_DELIVERY
    if (newStatus === 'OUT_FOR_DELIVERY' && shipment.order.paymentMethod === 'COD' && !shipment.order.payment?.cod_otp) {
      const otp = Math.floor(100000 + Math.random() * 900000).toString();
      const otpExpiresAt = new Date(Date.now() + 2 * 60 * 60 * 1000); // 2 hours
      
      await prisma.payment.update({
        where: { orderId: shipment.orderId },
        data: {
          cod_otp: otp,
          cod_otp_expires_at: otpExpiresAt,
          cod_attempts: 0
        }
      });
      
      console.log(`âœ… OTP auto-generated for COD order ${shipment.order.orderNumber}: ${otp}`);
    }

    // Mark COD payment as completed on delivery (if not already)
    if (newStatus === 'DELIVERED' && shipment.order.paymentMethod === 'COD') {
      await prisma.payment.update({
        where: { orderId: shipment.orderId },
        data: { status: 'COMPLETED' }
      });
    }

    // NOTE: Do NOT update order.status
    // Shipment.status and Order.status are INDEPENDENT
    // Order.status only tracks PAYMENT READINESS
    // Shipment.status tracks DELIVERY progress

    res.status(200).json({
      message: 'Webhook processed',
      shipment: updatedShipment
    });

  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: error.message });
  }
};

// ============================================================================
// LIST SHIPMENTS (For admin to see all shipments)
// ============================================================================
exports.listShipments = async (req, res) => {
  try {
    const { status, orderId } = req.query;

    let whereClause = {};
    if (status) whereClause.status = status;
    if (orderId) whereClause.orderId = parseInt(orderId);

    const shipments = await prisma.shipment.findMany({
      where: whereClause,
      include: {
        order: {
          include: {
            user: { select: { name: true, email: true, phone: true } },
            items: { include: { variant: { include: { product: true } } } }
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(shipments);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
