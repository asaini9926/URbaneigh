// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ==============================
// 1. AUTH & RBAC (Role Based Access Control)
// ==============================

model User {
  id            Int       @id @default(autoincrement())
  name          String?
  email         String?   @unique
  phone         String?   @unique
  password_hash String?
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relationships
  roles         UserRole[]
  orders        Order[]
  addresses     Address[]
  cart          Cart?
  tickets       Ticket[]
  auditLogs     AuditLog[] // Logs of actions done by this user
  returns       Return[]
  couponUsages  CouponUsage[]

  @@map("users")
}

model Role {
  id          Int       @id @default(autoincrement())
  name        String    @unique // e.g., "SuperAdmin", "CustomerSupport"
  description String?

  users       UserRole[]
  permissions RolePermission[]

  @@map("roles")
}

model Permission {
  id          Int       @id @default(autoincrement())
  action      String    @unique // e.g., "product.create", "order.verify_qr"
  description String?

  roles       RolePermission[]

  @@map("permissions")
}

// Explicit Join Tables for Granular Control
model UserRole {
  userId Int
  roleId Int
  user   User @relation(fields: [userId], references: [id])
  role   Role @relation(fields: [roleId], references: [id])

  @@id([userId, roleId])
  @@map("user_roles")
}

model RolePermission {
  roleId       Int
  permissionId Int
  role         Role       @relation(fields: [roleId], references: [id])
  permission   Permission @relation(fields: [permissionId], references: [id])

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

// ==============================
// 2. PRODUCT CATALOG
// ==============================

model Category {
  id          Int        @id @default(autoincrement())
  name        String
  slug        String     @unique
  parentId    Int?       // For subcategories
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  products    Product[]

  @@map("categories")
}

model Brand {
  id       Int       @id @default(autoincrement())
  name     String
  slug     String    @unique
  products Product[]

  @@map("brands")
}

model Product {
  id          Int              @id @default(autoincrement())
  title       String
  description String           @db.Text
  socialMediaDescription String? @db.Text
  categoryId  Int
  brandId     Int
  slug        String           @unique
  status      ProductStatus    @default(DRAFT)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  category    Category         @relation(fields: [categoryId], references: [id])
  brand       Brand            @relation(fields: [brandId], references: [id])
  variants    ProductVariant[]
  videos      ProductVideo[]

  @@fulltext([title]) // Enable Search
  @@map("products")
}

model ProductVariant {
  id        Int      @id @default(autoincrement())
  productId Int
  sku       String   @unique
  size      String?
  color     String?
  price     Decimal  @db.Decimal(10, 2) // Selling Price
  mrp       Decimal  @db.Decimal(10, 2) // Max Retail Price
  
  product   Product  @relation(fields: [productId], references: [id])
  images    ProductImage[]
  inventory Inventory?
  cartItems CartItem[]
  orderItems OrderItem[]

  @@map("product_variants")
}

model ProductImage {
  id        Int      @id @default(autoincrement())
  variantId Int
  url       String
  altText   String?
  position  Int      @default(0)

  variant   ProductVariant @relation(fields: [variantId], references: [id])

  @@map("product_images")
}

model Inventory {
  id               Int      @id @default(autoincrement())
  variantId        Int      @unique
  quantity         Int      @default(0)          // Total available quantity
  reserved_qty     Int      @default(0)          // Quantity on hold for payment-pending orders
  warehouseId      String?  // Optional for future scaling

  variant          ProductVariant @relation(fields: [variantId], references: [id])
  reservations     Reservation[]

  @@map("inventory")
}

// ==============================
// 3. CART & ORDERS
// ==============================

model Cart {
  id        Int        @id @default(autoincrement())
  userId    Int?       @unique
  sessionId String?    // For guest users
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  user      User?      @relation(fields: [userId], references: [id])
  items     CartItem[]

  @@map("carts")
}

model CartItem {
  id        Int      @id @default(autoincrement())
  cartId    Int
  variantId Int
  quantity  Int

  cart      Cart           @relation(fields: [cartId], references: [id])
  variant   ProductVariant @relation(fields: [variantId], references: [id])

  @@map("cart_items")
}

model Order {
  id              Int            @id @default(autoincrement())
  orderNumber     String         @unique
  userId          Int
  totalAmount     Decimal        @db.Decimal(10, 2)
  status          OrderStatus    @default(CREATED)  // Payment readiness only (7 states)
  fulfillmentStatus FulfillmentStatus @default(UNFULFILLED)
  paymentMethod   PaymentMethod
  shippingAddress Json           // Storing address snapshot to prevent history changes
  idempotencyKey  String         @unique // For idempotent order creation
  notes           String?        @db.Text       // Order history/notes
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  user            User           @relation(fields: [userId], references: [id])
  items           OrderItem[]
  payment         Payment?
  invoice         Invoice?
  tickets         Ticket[]
  reservations    Reservation[]
  shipments       Shipment[]
  return          Return?
  refund          Refund?
  reconciliationAlerts ReconciliationAlert[]
  couponUsages    CouponUsage[]

  @@map("orders")
}

model OrderItem {
  id        Int      @id @default(autoincrement())
  orderId   Int
  variantId Int
  quantity  Int
  price     Decimal  @db.Decimal(10, 2) // Price at moment of purchase
  
  order     Order          @relation(fields: [orderId], references: [id])
  variant   ProductVariant @relation(fields: [variantId], references: [id])

  @@map("order_items")
}

model Payment {
  id               Int           @id @default(autoincrement())
  orderId          Int           @unique
  method           PaymentMethod
  amount           Decimal       @db.Decimal(10, 2)
  status           PaymentStatus @default(PENDING)
  
  // Paytm Fields
  paytm_txn_id     String?       @unique
  paytm_txn_token  String?       // Temporary token for JS Checkout
  paytm_status     String?
  paytm_bank_txn_id String?      // Bank's internal Ref ID
  paytm_payment_mode String?     // UPI/CC/DC/NB
  gateway_response Json?         // Full Paytm API response
  
  // COD Fields
  cod_otp          String?       // OTP for delivery verification
  cod_otp_expires_at DateTime?   // OTP expiry time (2 hours)
  cod_verified_at  DateTime?
  cod_attempts     Int           @default(0)
  
  // Refund Fields
  refunded_at      DateTime?
  refund_amount    Decimal?      @db.Decimal(10, 2)
  refund_txn_id    String?
  
  // Settlement Fields (for COD)
  is_remitted      Boolean       @default(false)
  remitted_at      DateTime?
  remit_reference  String?

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  order            Order         @relation(fields: [orderId], references: [id])

  @@map("payments")
}

model Address {
  id          Int     @id @default(autoincrement())
  userId      Int
  fullAddress String
  pincode     String
  city        String
  state       String
  isDefault   Boolean @default(false)

  user        User    @relation(fields: [userId], references: [id])

  @@map("addresses")
}

model Invoice {
  id          Int      @id @default(autoincrement())
  orderId     Int      @unique
  pdfUrl      String
  generatedAt DateTime @default(now())

  order       Order    @relation(fields: [orderId], references: [id])

  @@map("invoices")
}

// ==============================
// 4. MARKETING & SUPPORT
// ==============================

model Poster {
  id         Int       @id @default(autoincrement())
  imageUrl   String
  link       String?
  position   String    // 'home_main', 'category_top'
  isActive   Boolean   @default(true)
  
  @@map("posters")
}

model ShoppableVideo {
  id          Int      @id @default(autoincrement())
  title       String
  videoUrl    String
  thumbnailUrl String?
  socialMediaDescription String? @db.Text
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  // Relations
  products    ProductVideo[]

  @@map("shoppable_videos")
}

model ProductVideo {
  videoId     Int
  productId   Int
  
  video       ShoppableVideo @relation(fields: [videoId], references: [id])
  product     Product        @relation(fields: [productId], references: [id])

  @@id([videoId, productId])
  @@map("product_videos")
}

model Ticket {
  id        Int          @id @default(autoincrement())
  userId    Int
  orderId   Int?
  subject   String
  status    TicketStatus @default(OPEN)
  messages  Json         // Array of { sender: 'user'|'admin', text: '...', time: '...' }
  createdAt DateTime     @default(now())

  user      User   @relation(fields: [userId], references: [id])
  order     Order? @relation(fields: [orderId], references: [id])

  @@map("tickets")
}

model AuditLog {
  id          Int      @id @default(autoincrement())
  actorId     Int
  action      String   // e.g., "ORDER_VERIFIED", "PRODUCT_UPDATED"
  entityType  String   // e.g., "Order"
  entityId    String   // ID of affected entity
  metadata    Json?    // Details of change
  createdAt   DateTime @default(now())

  actor       User     @relation(fields: [actorId], references: [id])

  @@map("audit_logs")
}

model Coupon {
  id          Int       @id @default(autoincrement())
  code        String    @unique
  type        String    // 'PERCENTAGE' or 'FIXED'
  value       Decimal   @db.Decimal(10, 2) // e.g., 10.00 or 100.00
  minOrderVal Decimal   @default(0) @db.Decimal(10, 2) // Min cart value required
  expiryDate  DateTime
  isActive    Boolean   @default(true)
  usageLimit  Int       @default(1000) // Max times it can be used
  usedCount   Int       @default(0)

  createdAt   DateTime  @default(now())
  
  usages      CouponUsage[]

  @@map("coupons")
}

model CouponUsage {
  id        Int      @id @default(autoincrement())
  couponId  Int
  userId    Int
  orderId   Int
  createdAt DateTime @default(now())

  coupon    Coupon   @relation(fields: [couponId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@unique([couponId, userId]) // A user can only use a specific coupon once
  @@map("coupon_usages")
}

// ==============================
// 6. RESERVATIONS (Stock Hold for Payments)
// ==============================

model Reservation {
  id           Int      @id @default(autoincrement())
  orderId      Int
  variantId    Int
  quantity     Int
  expiresAt    DateTime // Time when this hold expires if payment not completed
  status       ReservationStatus @default(ACTIVE) // ACTIVE, EXPIRED, RELEASED, FINALIZED
  createdAt    DateTime @default(now())

  order        Order          @relation(fields: [orderId], references: [id])
  inventory    Inventory      @relation(fields: [variantId], references: [variantId])

  @@map("reservations")
}

// ==============================
// 7. SHIPMENTS & DELIVERY (Delhivery Integration)
// ==============================

model Shipment {
  id               Int             @id @default(autoincrement())
  orderId          Int
  courier_provider String          // "DELHIVERY", "FEDEX", "SHIPROCKET", etc.
  waybill          String?         @unique // AWB number (Now optional initially)
  status           ShipmentStatus  @default(CREATED)  // Delivery status (independent)
  
  // Shiprocket Details
  shiprocket_order_id    Int?     // Shiprocket's internal Order ID
  shiprocket_shipment_id Int?     // Shiprocket's internal Shipment ID
  courier_name           String?  // Actual courier assigned (e.g., Ecom Express)
  awb_code               String?  // AWB Number (Redundant but keeps schema consistent)
  pickup_scheduled_date  DateTime?
  label_url              String?  // URL to download shipping label
  
  // Delhivery Details (Legacy - Keep for compatibility if needed)
  delhivery_waybill String?
  delhivery_manifest_id String?
  delhivery_pickup_id String?
  delhivery_last_status_update Json? // Last tracking payload from webhook
  
  // COD Details
  cod_amount       Decimal?        @db.Decimal(10, 2)
  
  // Warehouse Info
  warehouseId      String?
  pickedUpAt       DateTime?
  manifestedAt     DateTime?
  
  // Tracking & Delivery (moved from Order)
  last_tracking_update DateTime?
  estimated_delivery DateTime?
  delivered_at     DateTime?       // When was this shipment delivered
  failed_delivery_attempts Int    @default(0)  // RTO attempts for this shipment

  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  order            Order           @relation(fields: [orderId], references: [id])

  @@map("shipments")
}

// ==============================
// 8. COD REMITTANCE & RECONCILIATION
// ==============================

model CODRemittance {
  id                 Int       @id @default(autoincrement())
  remittanceDate     DateTime
  totalAmount        Decimal   @db.Decimal(10, 2)
  settlementDate     DateTime?
  status             RemittanceStatus @default(PENDING) // PENDING, SETTLED, VERIFIED
  reference_number   String    @unique // Delhivery or Bank reference
  bankTransactionId  String?
  notes              String?
  
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@map("cod_remittances")
}

// ==============================
// 9. RETURNS & REFUNDS (Phase 5)
// ==============================

model Return {
  id                      Int       @id @default(autoincrement())
  orderId                 Int       @unique
  userId                  Int
  status                  ReturnStatus @default(REQUESTED) // REQUESTED, APPROVED, REJECTED, IN_TRANSIT, RECEIVED, RETURNED
  reason                  String    // e.g., "WRONG_ITEM", "DAMAGED", "NOT_AS_DESCRIBED"
  description             String?   @db.Text
  items                   Json      // Array of { variantId, quantity, reason }
  proof_images            Json?     // Array of image URLs uploaded by user
  estimatedRefundAmount   Decimal   @db.Decimal(10, 2)
  approvedRefundAmount    Decimal?  @db.Decimal(10, 2) // Admin sets this after review
  
  // Shiprocket Return Details
  shiprocket_return_order_id Int?
  shiprocket_return_shipment_id Int?
  
  // Return Pickup Details
  pickupScheduledAt       DateTime?
  pickupCompletedAt       DateTime?
  returnWaybill           String?   // Reverse AWB number
  returnStatus            String?   // SCHEDULED, PICKED, IN_TRANSIT, RECEIVED
  
  // Condition Assessment
  conditionAssessment     String?   @db.Text // Admin notes on goods condition
  conditionScore          Int?      // 1-10 rating
  
  // Rejection Details (if admin rejects)
  rejectionReason         String?   // Reason for rejection
  rejectedAt              DateTime?
  
  // Timestamps
  requestedAt             DateTime  @default(now())
  approvedAt              DateTime?
  completedAt             DateTime?
  
  // Audit Trail
  notes                   String?   @db.Text
  updatedAt               DateTime  @updatedAt

  order                   Order     @relation(fields: [orderId], references: [id])
  user                    User      @relation(fields: [userId], references: [id])
  refund                  Refund?

  @@map("returns")
}

model Refund {
  id                Int       @id @default(autoincrement())
  orderId           Int       @unique
  returnId          Int?      @unique // Null if refund triggered by cancellation
  paymentId         Int?
  originalAmount    Decimal   @db.Decimal(10, 2)
  refundAmount      Decimal   @db.Decimal(10, 2)
  method            RefundMethod @default(GATEWAY) // GATEWAY (Paytm) or BANK_TRANSFER (COD)
  status            RefundStatus @default(PENDING) // PENDING, PROCESSING, COMPLETED, FAILED
  
  // Paytm Refund Fields
  paytm_refund_id   String?   @unique
  paytm_status      String?   // From Paytm refund API
  paytm_response    Json?
  
  // Bank Transfer Fields (for COD)
  bank_account      Json?     // { account_number, ifsc, name } (Deprecated in favor of granular fields below)
  bank_account_no   String?   // Encrypted/Masked (For COD)
  ifsc_code         String?   // For COD
  beneficiary_name  String?   // For COD
  
  settlement_date   DateTime?
  settlement_reference String?
  
  // Retry Logic
  retry_count       Int       @default(0)
  last_retry_at     DateTime?
  
  // Audit
  notes             String?   @db.Text
  initiatedAt       DateTime  @default(now())
  completedAt       DateTime?
  failedAt          DateTime?
  updatedAt         DateTime  @updatedAt

  order             Order     @relation(fields: [orderId], references: [id])
  return            Return?   @relation(fields: [returnId], references: [id])

  @@map("refunds")
}

model ReconciliationAlert {
  id            Int       @id @default(autoincrement())
  orderId       Int
  alert_type    String    // AMOUNT_MISMATCH, PAYMENT_NOT_RECEIVED, DUPLICATE_PAYMENT, etc.
  expected_amount Decimal  @db.Decimal(10, 2)
  actual_amount Decimal?   @db.Decimal(10, 2)
  difference    Decimal?   @db.Decimal(10, 2)
  status        String    @default("OPEN") // OPEN, RESOLVED, ESCALATED
  reference_id  String?
  resolution    String?
  resolved_amount Decimal? @db.Decimal(10, 2)
  resolved_at   DateTime?
  notes         String?   @db.Text
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt

  order         Order     @relation(fields: [orderId], references: [id])

  @@map("reconciliation_alerts")
}

// ==============================
// 10. ENUMS
// ==============================

enum ProductStatus {
  DRAFT
  ACTIVE
  ARCHIVED
}

enum OrderStatus {
  CREATED            // Order placed, awaiting payment
  PAYMENT_PENDING    // Payment gateway initiated
  PAYMENT_FAILED     // Payment failed/declined
  CONFIRMED          // COD order confirmed, awaiting fulfillment (payment on delivery)
  PAID               // Payment confirmed (online payment)
  READY_TO_PACK      // Order ready for warehouse to pack
  PACKED             // Order packed, ready for courier pickup
  READY_TO_PICK      // Ready for courier
  PICKED_UP          // Courier picked up
  IN_TRANSIT         // On the way
  OUT_FOR_DELIVERY   // Out for delivery
  DELIVERED          // Delivered
  CANCELLED          // Order cancelled, no longer valid
  RETURN_REQUESTED   // User requested return
  RETURNED           // Returned successfully
}

enum PaymentMethod {
  COD
  PAYTM
}

enum PaymentStatus {
  PENDING    // Awaiting payment initiation
  COMPLETED  // Payment confirmed
  FAILED     // Payment failed/declined
  REFUNDED   // Payment refunded
}

enum ReservationStatus {
  ACTIVE                  // Stock is currently reserved
  EXPIRED                 // Hold expired, stock released
  RELEASED                // Manually released
  FINALIZED               // Converted to permanent inventory deduction
}

enum ShipmentStatus {
  CREATED                 // Shipment record created
  MANIFESTED              // Added to courier manifest
  PICKED_UP               // Courier picked up
  IN_TRANSIT              // In transit
  OUT_FOR_DELIVERY        // Out for delivery
  DELIVERED               // Delivered
  FAILED                  // Delivery failed
  RETURN_INITIATED        // Return flow started
  CANCELLED               // Shipment was cancelled
}

enum FulfillmentStatus {
  UNFULFILLED
  PARTIALLY_FULFILLED
  FULFILLED
  RETURNED
}

enum RemittanceStatus {
  PENDING                 // Awaiting settlement from courier
  SETTLED                 // Amount credited to account
  VERIFIED                // Verified against bank statement
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum ReturnStatus {
  REQUESTED                // Customer requested return
  APPROVED                 // Admin approved the return
  REJECTED                 // Admin rejected the return
  PICKUP_SCHEDULED         // Return pickup scheduled with courier
  IN_TRANSIT               // Return item in transit back to warehouse
  RECEIVED                 // Return item received at warehouse
  RETURNED                 // Return process completed
}

enum RefundMethod {
  GATEWAY                  // Refund via payment gateway (Paytm)
  BANK_TRANSFER            // Direct bank transfer (for COD)
}

enum RefundStatus {
  PENDING                  // Refund initiated, awaiting processing
  PROCESSING               // Refund being processed
  COMPLETED                // Refund successfully completed
  FAILED                   // Refund failed
}

model Subscriber {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  @@map("subscribers")
}